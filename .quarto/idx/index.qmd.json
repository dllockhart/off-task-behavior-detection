{"title":"Off-task Behavior Detection","markdown":{"yaml":{"title":"Off-task Behavior Detection","author":"Demontray Lockhart","date":"12/23/2024"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\nThis project applies machine learning techniques to detect off-task behavior in students based on classroom data. \nIt leverages machine learning models to identify patterns in the data and uses cross-validation for model tuning.\n\n# Exploratory Data Analysis\nI import the necessary libraries to perform exploratory data analysis (EDA).\nNext, I load the dataset into a dataframe and generate descriptive statistics to understand the distribution and spread of the variables.\nI visualize the class distribution using a bar chart to identify any imbalance in the target variable.\nFinally, I create a correlation heatmap to examine relationships between the features and the target variable.\n```{python}\n# Import necessary libraries for exploratory data analysis (EDA)\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load the dataset into a pandas DataFrame\ndf = pd.read_csv(\"data/ca1-dataset.csv\")\n```\n```{python}\n# Display basic information about the dataset (column types, non-null counts)\ndf.info()\n```\n```{python}\n# Generate descriptive statistics to understand the distribution and spread of the data\ndf.describe()\n```\n```{python}\n# Visualize the distribution of the target variable ('OffTask') to check for class imbalance\nplt.figure(figsize=(6,4))\nsns.countplot(x='OffTask', data=df)\nplt.title(\"Class Distribution\")\nplt.show()\n```\n```{python}\n# Calculate and visualize correlations between numerical features\nnumeric_df = df.select_dtypes(include=['float64', 'int64'])\nplt.figure(figsize=(10, 8))\nsns.heatmap(numeric_df.corr(), annot=False, cmap='coolwarm')\nplt.title(\"Feature Correlation Matrix\")\nplt.show()\n```\nThe dataset consists of 763 entries and 27 columns, encompassing both numerical and categorical features.\n\nA review of the dataset reveals no missing values across columns, confirming data completeness. The dataset contains 15 float columns, 9 integer columns, and 3 object columns.\n\nDescriptive statistics highlight key patterns in the data:\n- 'Avgright' (average correctness) has a mean of 0.71, indicating students are often correct, with a standard deviation of 0.39.\n- 'Avgbug' (average errors) shows minimal occurrence, with a mean of 0.05.\n- Several features, such as 'Avghelp', 'Avgchoice', 'Avgstring', 'Avgnumber', 'Avgpoint', and 'AvgasymptoteA-up/B-up', consist entirely of zeros, suggesting they may be uninformative and could be removed during preprocessing.\n- The average time ('Avgtime') has a wide range, from -1 to 205, with a mean of 14.12 and notable variance (std = 15.62).\n- Features like 'AvgtimeSDnormed' and 'Avgpchange' exhibit both negative and positive values, which may indicate normalized or scaled data points.\n\nA bar chart of the target variable ('OffTask') highlights potential class imbalance, warranting further attention to address skewed distributions in model development.\n\nA correlation heatmap is generated to visualize relationships between numerical features. Metrics such as 'Avgtime', 'Avgtimeperact-up', and 'AvgPrev5Count-up' may reveal insights into patterns of off-task behavior.\n\nThe EDA process identifies redundant features with zero variance and confirms the dataset is well-structured for further preprocessing and model development. Addressing these redundant features will help streamline model performance and reduce unnecessary complexity.\n\n# Model Training & Evaluation\nI import the necessary libraries to train and evaluate multiple machine learning models. The dataset is prepared by removing non-predictive columns and eliminating features that contain only zero values.\n\nTo address class imbalance, I apply SMOTE (Synthetic Minority Over-sampling Technique) within each training fold, ensuring that synthetic samples are generated exclusively from the training data. This prevents data leakage and helps the models better recognize patterns in the minority class.\n\nI define three classifiers – Random Forest, Logistic Regression, and Support Vector Machine (SVM) – with class weights adjusted to mitigate the effects of class imbalance. For the Random Forest model, I implement a hyperparameter grid to fine-tune the model during training.\n\nI employ Stratified Group K-Fold cross-validation to maintain balanced class distributions across folds while accounting for group dependencies in the dataset. Within each fold, I apply GridSearchCV to optimize model parameters and evaluate performance on the test set.\n\nModel performance is assessed using the Cohen’s Kappa score and a classification report. The results for each classifier are aggregated, providing insights into overall performance across the cross-validation folds.\n\n```{python}\nfrom sklearn.model_selection import StratifiedGroupKFold, GridSearchCV\nfrom sklearn.metrics import cohen_kappa_score, classification_report\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import SVC\nfrom sklearn.pipeline import Pipeline\nfrom imblearn.over_sampling import SMOTE\nimport numpy as np\nimport pandas as pd\n\n# Data Preparation\nX = df.drop(columns=['Unique-id', 'OffTask', 'namea'])\ny = df['OffTask'].map({'N': 0, 'Y': 1})  # Map labels to binary (0, 1)\ngroups = df['namea']  # Grouping variable\n\n# Remove columns with all 0 values\nX = X.loc[:, (X != 0).any(axis=0)]\n\n# Define classifiers\nclassifiers = {\n    'Random Forest': RandomForestClassifier(class_weight='balanced'),\n    'Logistic Regression': LogisticRegression(max_iter=1000, class_weight='balanced'),\n    'SVM': SVC(probability=True, class_weight='balanced')\n}\n\n# Hyperparameter grid for Random Forest\nparam_grid_rf = {\n    'classifier__n_estimators': [100, 200],\n    'classifier__max_depth': [10, 20, None],\n    'classifier__min_samples_split': [2, 5, 10],\n    'classifier__min_samples_leaf': [1, 2, 4]\n}\n\n# Stratified Group KFold\ngkf = StratifiedGroupKFold(n_splits=5)\nresults = {}\n\n# Model Training and Evaluation Loop\nfor name, classifier in classifiers.items():\n    pipeline = Pipeline(steps=[\n        ('classifier', classifier)\n    ])\n    \n    param_grid = param_grid_rf if name == 'Random Forest' else {}\n\n    # Store results\n    fold_scores = []\n    y_true_all, y_pred_all = [], []\n\n    for train_idx, test_idx in gkf.split(X, y, groups):\n        # Train-test split\n        X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]\n        y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]\n\n        # Apply SMOTE only to the training data\n        smote = SMOTE(random_state=42)\n        X_train_res, y_train_res = smote.fit_resample(X_train, y_train)\n\n        # Perform GridSearchCV\n        grid_search = GridSearchCV(pipeline, param_grid, cv=3)\n        grid_search.fit(X_train_res, y_train_res)\n\n        # Make predictions on the test set\n        y_pred = grid_search.best_estimator_.predict(X_test)\n\n        # Store results for evaluation\n        fold_scores.append(cohen_kappa_score(y_test, y_pred))\n        y_true_all.extend(y_test)\n        y_pred_all.extend(y_pred)\n    \n    # Final performance metrics\n    overall_kappa = cohen_kappa_score(y_true_all, y_pred_all)\n    overall_report = classification_report(y_true_all, y_pred_all)\n\n    # Save Results\n    results[name] = {\n        'mean_kappa': np.mean(fold_scores),\n        'overall_kappa': overall_kappa,\n        'report': overall_report\n    }\n\n    # Print Performance\n    print(f\"\\n{name} Results\")\n    print(f\"Mean Kappa Across Folds: {np.mean(fold_scores):.2f}\")\n    print(f\"Overall Kappa: {overall_kappa:.2f}\")\n    print(overall_report)\n\n```\n**Model Performance Overview:**\n\n- Random Forest:\n    - Achieves an overall accuracy of 93%, but performance on the minority class remains limited, with a recall of 18% and an f1-score of 0.18 for class 1.\n    - The overall kappa score is 0.14, indicating poor agreement between predictions and actual labels.\n\n- Logistic Regression:\n    - Yields an accuracy of 77%, with the minority class recall at 56%, reflecting the model's ability to identify positive cases. However, low precision for the minority class results in an f1-score of 0.18.\n    - The overall kappa score is 0.11, indicating slight agreement and limited predictive power for the minority class.\n\n- SVM:\n    - SVM demonstrates the highest minority class recall at 62% but maintains low precision, resulting in an f1-score of 0.23.\n    - With an overall accuracy of 82% and a kappa score of 0.18, SVM slightly outperforms the other models in balancing sensitivity to the minority class and overall accuracy.\n\n**Key Insights:**\nAcross all models, performance on the majority class (class 0) remains consistently high, while minority class detection (class 1) continues to present challenges. Despite applying SMOTE and adjusting class weights, low f1-scores and precision for the minority class indicate the need for:\n- Enhanced resampling techniques (e.g., ADASYN, Tomek links).\n- Feature engineering to improve class separability.\n- Exploration of ensemble methods or cost-sensitive learning to refine the model's ability to detect minority class instances.\n\nWhile SVM offers the best balance between recall and accuracy, further optimization is required to increase precision and overall model robustness when handling imbalanced datasets.\n\n# Visualizing the Peformance\nI import the necessary libraries to evaluate model performance through Receiver Operating Characteristic (ROC) curves and Area Under the Curve (AUC) metrics.\nA pipeline is created for each classifier, and the models are trained on the entire dataset without cross-validation to simplify visualization.\n\nThe models generate probability predictions for the positive class, which are used to calculate the ROC curve and AUC score.\nThe ROC curves for each classifier are plotted to compare performance, with a diagonal reference line representing random guessing.\n\nThe plot is finalized with titles, axis labels, and a legend to provide a clear visual comparison of model performance across different classifiers.\n```{python}\n## Visualize Performance\n\nfrom sklearn.metrics import roc_curve, auc, ConfusionMatrixDisplay\n\n\n# Visualize Performance\nplt.figure(figsize=(10, 7))\n\nfor name, classifier in classifiers.items():\n    # Create a simple pipeline with just the classifier\n    pipeline = Pipeline(steps=[\n        ('classifier', classifier)\n    ])\n    \n    # Fit the pipeline on the entire dataset (no cross-validation for visualization)\n    pipeline.fit(X, y)\n    \n    # Predict probabilities for the positive class\n    y_proba = pipeline.predict_proba(X)[:, 1]\n    \n    # Calculate ROC Curve and AUC\n    fpr, tpr, _ = roc_curve(y, y_proba)\n    roc_auc = auc(fpr, tpr)\n    \n    # Plot ROC Curve for each classifier\n    plt.plot(fpr, tpr, label=f'{name} (AUC = {roc_auc:.2f})')\n\n# Plot diagonal reference line\nplt.plot([0, 1], [0, 1], linestyle='--', color='grey')\n\n# Finalize plot details\nplt.title('ROC Curve Comparison')\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.legend(loc='lower right')\nplt.show()\n```\n\nThe ROC curve highlights notable differences between the models:\n- Random Forest achieves a perfect AUC of 1.00, indicating overfitting or high reliance on the majority class.\n- SVM demonstrates strong performance with an AUC of 0.87, suggesting better generalization to minority class patterns.\n- Logistic Regression achieves an AUC of 0.84, reflecting slightly lower discrimination ability compared to SVM.\n\nThe visualization underscores the trade-off between sensitivity and specificity, with SVM and Logistic Regression showing promising performance, while Random Forest's perfect AUC suggests further investigation into overfitting.\n\n# Conclusion\nThe evaluation and visualization of three classifiers – Random Forest, Logistic Regression, and Support Vector Machine (SVM) – reveal significant performance differences, particularly in handling class imbalance.\n\n- Random Forest achieves the highest overall accuracy and a perfect AUC score, but this likely indicates overfitting or an inability to generalize to the minority class. Despite high overall accuracy, the model struggles to detect minority class instances (low recall and f1-score).\n- SVM offers the best balance between minority class recall (62%) and overall accuracy, with an AUC of 0.87 suggesting better generalization compared to Random Forest.\n- Logistic Regression provides moderate performance, with a recall of 56% for the minority class and an AUC of 0.84, indicating acceptable discrimination but lower precision.\n\nDespite SMOTE application and class weight adjustments, all models exhibit limited precision for the minority class, highlighting the need for further refinement. The ROC curve suggests SVM outperforms the other models in minority class detection, making it the most promising model for deployment.\n\n### Future Work\nTo enhance model performance, particularly for the minority class, future efforts will focus on addressing overfitting in Random Forest and improving recall-precision balance in all classifiers.\n\n**Key Areas for Improvement:**\n- Overfitting Mitigation (Random Forest):\n    - Regularize the Random Forest model by limiting the maximum depth and increasing minimum samples per leaf.\n    - Experiment with Balanced Random Forest to reduce reliance on the majority class.\n\n- Resampling Techniques:\n    - Continue exploring SMOTE variations (e.g., ADASYN) or hybrid approaches (combining oversampling and undersampling).\n    - Apply Tomek Links or Cluster Centroids to remove overlapping majority class samples.\n\n- Advanced Models and Ensemble Methods:\n    - Implement ensemble models such as XGBoost, LightGBM, or CatBoost, which handle imbalanced datasets more effectively.\n    - Investigate cost-sensitive learning to penalize misclassification of the minority class.\n\n- Threshold Tuning:\n    - Adjust classification thresholds to optimize the precision-recall trade-off, particularly for SVM and Logistic Regression.\n    - Use Precision-Recall Curves to select operating points that maximize minority class detection.\n\n- Feature Engineering:\n    - Derive new features that better separate minority class samples using domain knowledge.\n    - Perform dimensionality reduction (PCA, LDA) to highlight the most discriminative features.\n\n- Cross-Validation Refinement:\n    - Use nested cross-validation to tune hyperparameters and reduce overfitting.\n    - Apply stratified k-fold cross-validation with SMOTE applied within each fold to prevent data leakage.\n\nBy integrating these improvements, the goal is to enhance the recall and precision of minority class detection while ensuring high overall model accuracy and reduced overfitting, making the models more reliable for real-world deployment.","srcMarkdownNoYaml":"\n\n# Introduction\nThis project applies machine learning techniques to detect off-task behavior in students based on classroom data. \nIt leverages machine learning models to identify patterns in the data and uses cross-validation for model tuning.\n\n# Exploratory Data Analysis\nI import the necessary libraries to perform exploratory data analysis (EDA).\nNext, I load the dataset into a dataframe and generate descriptive statistics to understand the distribution and spread of the variables.\nI visualize the class distribution using a bar chart to identify any imbalance in the target variable.\nFinally, I create a correlation heatmap to examine relationships between the features and the target variable.\n```{python}\n# Import necessary libraries for exploratory data analysis (EDA)\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Load the dataset into a pandas DataFrame\ndf = pd.read_csv(\"data/ca1-dataset.csv\")\n```\n```{python}\n# Display basic information about the dataset (column types, non-null counts)\ndf.info()\n```\n```{python}\n# Generate descriptive statistics to understand the distribution and spread of the data\ndf.describe()\n```\n```{python}\n# Visualize the distribution of the target variable ('OffTask') to check for class imbalance\nplt.figure(figsize=(6,4))\nsns.countplot(x='OffTask', data=df)\nplt.title(\"Class Distribution\")\nplt.show()\n```\n```{python}\n# Calculate and visualize correlations between numerical features\nnumeric_df = df.select_dtypes(include=['float64', 'int64'])\nplt.figure(figsize=(10, 8))\nsns.heatmap(numeric_df.corr(), annot=False, cmap='coolwarm')\nplt.title(\"Feature Correlation Matrix\")\nplt.show()\n```\nThe dataset consists of 763 entries and 27 columns, encompassing both numerical and categorical features.\n\nA review of the dataset reveals no missing values across columns, confirming data completeness. The dataset contains 15 float columns, 9 integer columns, and 3 object columns.\n\nDescriptive statistics highlight key patterns in the data:\n- 'Avgright' (average correctness) has a mean of 0.71, indicating students are often correct, with a standard deviation of 0.39.\n- 'Avgbug' (average errors) shows minimal occurrence, with a mean of 0.05.\n- Several features, such as 'Avghelp', 'Avgchoice', 'Avgstring', 'Avgnumber', 'Avgpoint', and 'AvgasymptoteA-up/B-up', consist entirely of zeros, suggesting they may be uninformative and could be removed during preprocessing.\n- The average time ('Avgtime') has a wide range, from -1 to 205, with a mean of 14.12 and notable variance (std = 15.62).\n- Features like 'AvgtimeSDnormed' and 'Avgpchange' exhibit both negative and positive values, which may indicate normalized or scaled data points.\n\nA bar chart of the target variable ('OffTask') highlights potential class imbalance, warranting further attention to address skewed distributions in model development.\n\nA correlation heatmap is generated to visualize relationships between numerical features. Metrics such as 'Avgtime', 'Avgtimeperact-up', and 'AvgPrev5Count-up' may reveal insights into patterns of off-task behavior.\n\nThe EDA process identifies redundant features with zero variance and confirms the dataset is well-structured for further preprocessing and model development. Addressing these redundant features will help streamline model performance and reduce unnecessary complexity.\n\n# Model Training & Evaluation\nI import the necessary libraries to train and evaluate multiple machine learning models. The dataset is prepared by removing non-predictive columns and eliminating features that contain only zero values.\n\nTo address class imbalance, I apply SMOTE (Synthetic Minority Over-sampling Technique) within each training fold, ensuring that synthetic samples are generated exclusively from the training data. This prevents data leakage and helps the models better recognize patterns in the minority class.\n\nI define three classifiers – Random Forest, Logistic Regression, and Support Vector Machine (SVM) – with class weights adjusted to mitigate the effects of class imbalance. For the Random Forest model, I implement a hyperparameter grid to fine-tune the model during training.\n\nI employ Stratified Group K-Fold cross-validation to maintain balanced class distributions across folds while accounting for group dependencies in the dataset. Within each fold, I apply GridSearchCV to optimize model parameters and evaluate performance on the test set.\n\nModel performance is assessed using the Cohen’s Kappa score and a classification report. The results for each classifier are aggregated, providing insights into overall performance across the cross-validation folds.\n\n```{python}\nfrom sklearn.model_selection import StratifiedGroupKFold, GridSearchCV\nfrom sklearn.metrics import cohen_kappa_score, classification_report\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import SVC\nfrom sklearn.pipeline import Pipeline\nfrom imblearn.over_sampling import SMOTE\nimport numpy as np\nimport pandas as pd\n\n# Data Preparation\nX = df.drop(columns=['Unique-id', 'OffTask', 'namea'])\ny = df['OffTask'].map({'N': 0, 'Y': 1})  # Map labels to binary (0, 1)\ngroups = df['namea']  # Grouping variable\n\n# Remove columns with all 0 values\nX = X.loc[:, (X != 0).any(axis=0)]\n\n# Define classifiers\nclassifiers = {\n    'Random Forest': RandomForestClassifier(class_weight='balanced'),\n    'Logistic Regression': LogisticRegression(max_iter=1000, class_weight='balanced'),\n    'SVM': SVC(probability=True, class_weight='balanced')\n}\n\n# Hyperparameter grid for Random Forest\nparam_grid_rf = {\n    'classifier__n_estimators': [100, 200],\n    'classifier__max_depth': [10, 20, None],\n    'classifier__min_samples_split': [2, 5, 10],\n    'classifier__min_samples_leaf': [1, 2, 4]\n}\n\n# Stratified Group KFold\ngkf = StratifiedGroupKFold(n_splits=5)\nresults = {}\n\n# Model Training and Evaluation Loop\nfor name, classifier in classifiers.items():\n    pipeline = Pipeline(steps=[\n        ('classifier', classifier)\n    ])\n    \n    param_grid = param_grid_rf if name == 'Random Forest' else {}\n\n    # Store results\n    fold_scores = []\n    y_true_all, y_pred_all = [], []\n\n    for train_idx, test_idx in gkf.split(X, y, groups):\n        # Train-test split\n        X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]\n        y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]\n\n        # Apply SMOTE only to the training data\n        smote = SMOTE(random_state=42)\n        X_train_res, y_train_res = smote.fit_resample(X_train, y_train)\n\n        # Perform GridSearchCV\n        grid_search = GridSearchCV(pipeline, param_grid, cv=3)\n        grid_search.fit(X_train_res, y_train_res)\n\n        # Make predictions on the test set\n        y_pred = grid_search.best_estimator_.predict(X_test)\n\n        # Store results for evaluation\n        fold_scores.append(cohen_kappa_score(y_test, y_pred))\n        y_true_all.extend(y_test)\n        y_pred_all.extend(y_pred)\n    \n    # Final performance metrics\n    overall_kappa = cohen_kappa_score(y_true_all, y_pred_all)\n    overall_report = classification_report(y_true_all, y_pred_all)\n\n    # Save Results\n    results[name] = {\n        'mean_kappa': np.mean(fold_scores),\n        'overall_kappa': overall_kappa,\n        'report': overall_report\n    }\n\n    # Print Performance\n    print(f\"\\n{name} Results\")\n    print(f\"Mean Kappa Across Folds: {np.mean(fold_scores):.2f}\")\n    print(f\"Overall Kappa: {overall_kappa:.2f}\")\n    print(overall_report)\n\n```\n**Model Performance Overview:**\n\n- Random Forest:\n    - Achieves an overall accuracy of 93%, but performance on the minority class remains limited, with a recall of 18% and an f1-score of 0.18 for class 1.\n    - The overall kappa score is 0.14, indicating poor agreement between predictions and actual labels.\n\n- Logistic Regression:\n    - Yields an accuracy of 77%, with the minority class recall at 56%, reflecting the model's ability to identify positive cases. However, low precision for the minority class results in an f1-score of 0.18.\n    - The overall kappa score is 0.11, indicating slight agreement and limited predictive power for the minority class.\n\n- SVM:\n    - SVM demonstrates the highest minority class recall at 62% but maintains low precision, resulting in an f1-score of 0.23.\n    - With an overall accuracy of 82% and a kappa score of 0.18, SVM slightly outperforms the other models in balancing sensitivity to the minority class and overall accuracy.\n\n**Key Insights:**\nAcross all models, performance on the majority class (class 0) remains consistently high, while minority class detection (class 1) continues to present challenges. Despite applying SMOTE and adjusting class weights, low f1-scores and precision for the minority class indicate the need for:\n- Enhanced resampling techniques (e.g., ADASYN, Tomek links).\n- Feature engineering to improve class separability.\n- Exploration of ensemble methods or cost-sensitive learning to refine the model's ability to detect minority class instances.\n\nWhile SVM offers the best balance between recall and accuracy, further optimization is required to increase precision and overall model robustness when handling imbalanced datasets.\n\n# Visualizing the Peformance\nI import the necessary libraries to evaluate model performance through Receiver Operating Characteristic (ROC) curves and Area Under the Curve (AUC) metrics.\nA pipeline is created for each classifier, and the models are trained on the entire dataset without cross-validation to simplify visualization.\n\nThe models generate probability predictions for the positive class, which are used to calculate the ROC curve and AUC score.\nThe ROC curves for each classifier are plotted to compare performance, with a diagonal reference line representing random guessing.\n\nThe plot is finalized with titles, axis labels, and a legend to provide a clear visual comparison of model performance across different classifiers.\n```{python}\n## Visualize Performance\n\nfrom sklearn.metrics import roc_curve, auc, ConfusionMatrixDisplay\n\n\n# Visualize Performance\nplt.figure(figsize=(10, 7))\n\nfor name, classifier in classifiers.items():\n    # Create a simple pipeline with just the classifier\n    pipeline = Pipeline(steps=[\n        ('classifier', classifier)\n    ])\n    \n    # Fit the pipeline on the entire dataset (no cross-validation for visualization)\n    pipeline.fit(X, y)\n    \n    # Predict probabilities for the positive class\n    y_proba = pipeline.predict_proba(X)[:, 1]\n    \n    # Calculate ROC Curve and AUC\n    fpr, tpr, _ = roc_curve(y, y_proba)\n    roc_auc = auc(fpr, tpr)\n    \n    # Plot ROC Curve for each classifier\n    plt.plot(fpr, tpr, label=f'{name} (AUC = {roc_auc:.2f})')\n\n# Plot diagonal reference line\nplt.plot([0, 1], [0, 1], linestyle='--', color='grey')\n\n# Finalize plot details\nplt.title('ROC Curve Comparison')\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.legend(loc='lower right')\nplt.show()\n```\n\nThe ROC curve highlights notable differences between the models:\n- Random Forest achieves a perfect AUC of 1.00, indicating overfitting or high reliance on the majority class.\n- SVM demonstrates strong performance with an AUC of 0.87, suggesting better generalization to minority class patterns.\n- Logistic Regression achieves an AUC of 0.84, reflecting slightly lower discrimination ability compared to SVM.\n\nThe visualization underscores the trade-off between sensitivity and specificity, with SVM and Logistic Regression showing promising performance, while Random Forest's perfect AUC suggests further investigation into overfitting.\n\n# Conclusion\nThe evaluation and visualization of three classifiers – Random Forest, Logistic Regression, and Support Vector Machine (SVM) – reveal significant performance differences, particularly in handling class imbalance.\n\n- Random Forest achieves the highest overall accuracy and a perfect AUC score, but this likely indicates overfitting or an inability to generalize to the minority class. Despite high overall accuracy, the model struggles to detect minority class instances (low recall and f1-score).\n- SVM offers the best balance between minority class recall (62%) and overall accuracy, with an AUC of 0.87 suggesting better generalization compared to Random Forest.\n- Logistic Regression provides moderate performance, with a recall of 56% for the minority class and an AUC of 0.84, indicating acceptable discrimination but lower precision.\n\nDespite SMOTE application and class weight adjustments, all models exhibit limited precision for the minority class, highlighting the need for further refinement. The ROC curve suggests SVM outperforms the other models in minority class detection, making it the most promising model for deployment.\n\n### Future Work\nTo enhance model performance, particularly for the minority class, future efforts will focus on addressing overfitting in Random Forest and improving recall-precision balance in all classifiers.\n\n**Key Areas for Improvement:**\n- Overfitting Mitigation (Random Forest):\n    - Regularize the Random Forest model by limiting the maximum depth and increasing minimum samples per leaf.\n    - Experiment with Balanced Random Forest to reduce reliance on the majority class.\n\n- Resampling Techniques:\n    - Continue exploring SMOTE variations (e.g., ADASYN) or hybrid approaches (combining oversampling and undersampling).\n    - Apply Tomek Links or Cluster Centroids to remove overlapping majority class samples.\n\n- Advanced Models and Ensemble Methods:\n    - Implement ensemble models such as XGBoost, LightGBM, or CatBoost, which handle imbalanced datasets more effectively.\n    - Investigate cost-sensitive learning to penalize misclassification of the minority class.\n\n- Threshold Tuning:\n    - Adjust classification thresholds to optimize the precision-recall trade-off, particularly for SVM and Logistic Regression.\n    - Use Precision-Recall Curves to select operating points that maximize minority class detection.\n\n- Feature Engineering:\n    - Derive new features that better separate minority class samples using domain knowledge.\n    - Perform dimensionality reduction (PCA, LDA) to highlight the most discriminative features.\n\n- Cross-Validation Refinement:\n    - Use nested cross-validation to tune hyperparameters and reduce overfitting.\n    - Apply stratified k-fold cross-validation with SMOTE applied within each fold to prevent data leakage.\n\nBy integrating these improvements, the goal is to enhance the recall and precision of minority class detection while ensuring high overall model accuracy and reduced overfitting, making the models more reliable for real-world deployment."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.39","title":"Off-task Behavior Detection","author":"Demontray Lockhart","date":"12/23/2024"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}